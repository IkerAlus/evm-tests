Creating Typechain artifacts in directory typechain for target ethers-v5
Successfully generated Typechain artifacts!


  BitMath
    #mostSignificantBit
      ✔ 0
      ✔ 1
      ✔ 2
      ✔ all powers of 2 (147ms)
      ✔ uint256(-1)
      ✔ gas cost of smaller number
      ✔ gas cost of max uint128
      ✔ gas cost of max uint256
    #leastSignificantBit
      ✔ 0
      ✔ 1
      ✔ 2
      ✔ all powers of 2 (80ms)
      ✔ uint256(-1)
      ✔ gas cost of smaller number
      ✔ gas cost of max uint128
      ✔ gas cost of max uint256

  FullMath
    - check a bunch of random inputs against JS implementation
    #mulDiv
      ✔ reverts if denominator is 0
      ✔ reverts if denominator is 0 and numerator overflows
      ✔ reverts if output overflows uint256
      ✔ reverts if output overflows uint256
      ✔ reverts on overflow with all max inputs
      ✔ all max inputs
      ✔ accurate without phantom overflow
      ✔ accurate with phantom overflow
      ✔ accurate with phantom overflow and repeating decimal
    #mulDivRoundingUp
      ✔ reverts if denominator is 0
      ✔ reverts if denominator is 0 and numerator overflows
      ✔ reverts if output overflows uint256
      ✔ reverts on overflow with all max inputs
      ✔ reverts if mulDiv overflows 256 bits after rounding up
      ✔ reverts if mulDiv overflows 256 bits after rounding up case 2
      ✔ all max inputs
      ✔ accurate without phantom overflow
      ✔ accurate with phantom overflow
      ✔ accurate with phantom overflow and repeating decimal

  LiquidityMath
    #addDelta
      ✔ 1 + 0
      ✔ 1 + -1
      ✔ 1 + 1
      ✔ 2**128-15 + 15 overflows
      ✔ 0 + -1 underflows
      ✔ 3 + -4 underflows
      ✔ gas add
      ✔ gas sub

  NoDelegateCall
    ✔ runtime overhead
    ✔ proxy can call the method without the modifier
    ✔ proxy cannot call the method with the modifier
    ✔ can call the method that calls into a private method with the modifier

  Oracle
    #initialize
      ✔ index is 0 (466ms)
      ✔ cardinality is 1
      ✔ cardinality next is 1
      ✔ sets first slot timestamp only
      ✔ gas
    #grow
      ✔ increases the cardinality next for the first call (2064ms)
      ✔ does not touch the first slot
      ✔ is no op if oracle is already gte that size
      ✔ adds data to all the slots
      ✔ grow after wrap
      ✔ gas for growing by 1 slot when index == cardinality - 1
      ✔ gas for growing by 10 slots when index == cardinality - 1 (1440ms)
      ✔ gas for growing by 1 slot when index != cardinality - 1
      ✔ gas for growing by 10 slots when index != cardinality - 1 (303ms)
    #write
      ✔ single element array gets overwritten (39ms)
      ✔ does nothing if time has not changed
      ✔ writes an index if time has changed
      ✔ grows cardinality when writing past (43ms)
      ✔ wraps around
      ✔ accumulates liquidity
    #observe
      before initialization
        ✔ fails before initialize
        ✔ fails if an older observation does not exist
        ✔ does not fail across overflow boundary
        ✔ interpolates correctly at max liquidity (506ms)
        ✔ interpolates correctly at min liquidity
        ✔ interpolates the same as 0 liquidity for 1 liquidity
        ✔ interpolates correctly across uint32 seconds boundaries
        ✔ single observation at current time
        ✔ single observation in past but not earlier than secondsAgo
        ✔ single observation in past at exactly seconds ago
        ✔ single observation in past counterfactual in past
        ✔ single observation in past counterfactual now
        ✔ two observations in chronological order 0 seconds ago exact
        ✔ two observations in chronological order 0 seconds ago counterfactual
        ✔ two observations in chronological order seconds ago is exactly on first observation
        ✔ two observations in chronological order seconds ago is between first and second
        ✔ two observations in reverse order 0 seconds ago exact
        ✔ two observations in reverse order 0 seconds ago counterfactual
        ✔ two observations in reverse order seconds ago is exactly on first observation
        ✔ two observations in reverse order seconds ago is between first and second
        ✔ can fetch multiple observations (458ms)
        ✔ gas for observe since most recent
        ✔ gas for single observation at current time
        ✔ gas for single observation at current time counterfactually computed
      initialized with 5 observations with starting time of 5
        ✔ index, cardinality, cardinality next
        ✔ latest observation same time as latest
        ✔ latest observation 5 seconds after latest
        ✔ current observation 5 seconds after latest
        ✔ between latest observation and just before latest observation at same time as latest
        ✔ between latest observation and just before latest observation after the latest observation
        ✔ older than oldest reverts
        ✔ oldest observation
        ✔ oldest observation after some time
        ✔ fetch many values
        ✔ gas all of last 20 seconds
        ✔ gas latest equal
        ✔ gas latest transform
        ✔ gas oldest
        ✔ gas between oldest and oldest + 1
        ✔ gas middle
      initialized with 5 observations with starting time of 4294967291
        ✔ index, cardinality, cardinality next
        ✔ latest observation same time as latest
        ✔ latest observation 5 seconds after latest
        ✔ current observation 5 seconds after latest
        ✔ between latest observation and just before latest observation at same time as latest
        ✔ between latest observation and just before latest observation after the latest observation
        ✔ older than oldest reverts
        ✔ oldest observation
        ✔ oldest observation after some time
        ✔ fetch many values
        ✔ gas all of last 20 seconds
        ✔ gas latest equal
        ✔ gas latest transform
        ✔ gas oldest
        ✔ gas between oldest and oldest + 1
        ✔ gas middle
    full oracle
      - has max cardinality next
      - has max cardinality
      - index wrapped around
      - can observe into the ordered portion with exact seconds ago
      - can observe into the ordered portion with unexact seconds ago
      - can observe at exactly the latest observation
      - can observe at exactly the latest observation after some time passes
      - can observe after the latest observation counterfactual
      - can observe into the unordered portion of array at exact seconds ago of observation
      - can observe into the unordered portion of array at seconds ago between observations
      - can observe the oldest observation 13*65534 seconds ago
      - can observe the oldest observation 13*65534 + 5 seconds ago if time has elapsed
      - gas cost of observe(0)
      - gas cost of observe(200 * 13)
      - gas cost of observe(200 * 13 + 5)
      - gas cost of observe(0) after 5 seconds
      - gas cost of observe(5) after 5 seconds
      - gas cost of observe(oldest)
      - gas cost of observe(oldest) after 5 seconds

  SqrtPriceMath
    #getNextSqrtPriceFromInput
      ✔ fails if price is zero
      ✔ fails if liquidity is zero
      ✔ fails if input amount overflows the price
      ✔ any input amount cannot underflow the price
      ✔ returns input price if amount in is zero and zeroForOne = true
      ✔ returns input price if amount in is zero and zeroForOne = false
      ✔ returns the minimum price for max inputs
      ✔ input amount of 0.1 token1
      ✔ input amount of 0.1 token0
      ✔ amountIn > type(uint96).max and zeroForOne = true
      ✔ can return 1 with enough amountIn and zeroForOne = true
      ✔ zeroForOne = true gas
      ✔ zeroForOne = false gas
    #getNextSqrtPriceFromOutput
      ✔ fails if price is zero
      ✔ fails if liquidity is zero
      ✔ fails if output amount is exactly the virtual reserves of token0
      ✔ fails if output amount is greater than virtual reserves of token0
      ✔ fails if output amount is greater than virtual reserves of token1
      ✔ fails if output amount is exactly the virtual reserves of token1
      ✔ succeeds if output amount is just less than the virtual reserves of token1
      ✔ puzzling echidna test
      ✔ returns input price if amount in is zero and zeroForOne = true
      ✔ returns input price if amount in is zero and zeroForOne = false
      ✔ output amount of 0.1 token1
      ✔ output amount of 0.1 token1
      ✔ reverts if amountOut is impossible in zero for one direction
      ✔ reverts if amountOut is impossible in one for zero direction
      ✔ zeroForOne = true gas
      ✔ zeroForOne = false gas
    #getAmount0Delta
      ✔ returns 0 if liquidity is 0
      ✔ returns 0 if prices are equal
      ✔ returns 0.1 amount1 for price of 1 to 1.21
      ✔ works for prices that overflow
      ✔ gas cost for amount0 where roundUp = true
      ✔ gas cost for amount0 where roundUp = true
    #getAmount1Delta
      ✔ returns 0 if liquidity is 0
      ✔ returns 0 if prices are equal
      ✔ returns 0.1 amount1 for price of 1 to 1.21
      ✔ gas cost for amount0 where roundUp = true
      ✔ gas cost for amount0 where roundUp = false
    swap computation
      ✔ sqrtP * sqrtQ overflows

  SwapMath
    #computeSwapStep
      ✔ exact amount in that gets capped at price target in one for zero
      ✔ exact amount out that gets capped at price target in one for zero
      ✔ exact amount in that is fully spent in one for zero
      ✔ exact amount out that is fully received in one for zero
      ✔ amount out is capped at the desired amount out
      ✔ target price of 1 uses partial input amount
      ✔ entire input amount taken as fee
      ✔ handles intermediate insufficient liquidity in zero for one exact output case
      ✔ handles intermediate insufficient liquidity in one for zero exact output case
      gas
        ✔ swap one for zero exact in capped
        ✔ swap zero for one exact in capped
        ✔ swap one for zero exact out capped
        ✔ swap zero for one exact out capped
        ✔ swap one for zero exact in partial
        ✔ swap zero for one exact in partial
        ✔ swap one for zero exact out partial
        ✔ swap zero for one exact out partial

  Tick
    #tickSpacingToMaxLiquidityPerTick
      ✔ returns the correct value for low fee
      ✔ returns the correct value for medium fee
      ✔ returns the correct value for high fee
      ✔ returns the correct value for entire range
      ✔ returns the correct value for 2302
    #getFeeGrowthInside
      ✔ returns all for two uninitialized ticks if tick is inside (1024ms)
      ✔ returns 0 for two uninitialized ticks if tick is above (1122ms)
